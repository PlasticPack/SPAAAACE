/*
Auteur originel: Michael Thomas Greer
Modifié par Tristan Roy afin de permettre d'ajouter une plage de couleur au tableaux fournis
ainsi que de régulariser le Hue et de respecter les valeurs RGB.
*/

//
// Convert an array of integer values to a bitmap.
// Copyright 2009 Michael Thomas Greer
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//

#ifndef INTARRAY2BMP_HPP
#define INTARRAY2BMP_HPP

#define TYPE_VOLCANIC 0
#define TYPE_DESERT_TATAOUINE 1
#define TYPE_DESERT_GEO 2
#define TYPE_DESERT_MARS 3
#define TYPE_EARTHLIKE_FOREST 4
#define TYPE_EARTHLIKE_TROPIC 5
#define TYPE_EARTHLIKE_CYPRA 6
#define TYPE_EARTHLIKE_MAGMA 7
#define TYPE_ICE_ICE_BABY 8
#define TYPE_GAS_SATURN 9
#define TYPE_GAS_NEPTUNE 10
#define TYPE_GAS_PALESHELTER 11

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <fstream>
#include <iostream>
#include <string>

namespace intarray2bmp
{

	//-------------------------------------------------------------------------- 
	// This little helper is to write little-endian values to file.
	//
	struct lwrite
	{
		unsigned long value;
		unsigned      size;
		lwrite(unsigned long value, unsigned size) :
			value(value), size(size)
		{ }
	};

	//--------------------------------------------------------------------------
	inline std::ostream& operator << (std::ostream& outs, const lwrite& v)
	{
		unsigned long value = v.value;
		for (unsigned cntr = 0; cntr < v.size; cntr++, value >>= 8)
			outs.put(static_cast <char> (value & 0xFF));
		return outs;
	}

	//--------------------------------------------------------------------------
	// Take an integer array and convert it into a color image.
	//
	// This first version takes an array of array style of array:
	//   int* a[ 10 ]
	//
	// The second, overloaded version takes a flat C-style array:
	//   int a[ 10 ][ 10 ]
	//
	template <typename IntType>
	bool intarray2bmp(
		const std::string& filename,
		IntType**          intarray,
		unsigned           rows,
		unsigned           columns,
		IntType            min_value,
		IntType            max_value,
		IntType                type
		) {
		// This is the difference between each color based upon
		// the number of distinct values in the input array.
		double granularity = 360.0 / ((double)(max_value - min_value) + 1);

		// Open the output BMP file
		std::ofstream f(filename.c_str(),
			std::ios::out | std::ios::trunc | std::ios::binary);
		if (!f) return false;

		// Some basic
		unsigned long headers_size = 14  // sizeof( BITMAPFILEHEADER )
			+ 40; // sizeof( BITMAPINFOHEADER )
		unsigned long padding_size = (4 - ((columns * 3) % 4)) % 4;
		unsigned long pixel_data_size = rows * ((columns * 3) + padding_size);

		// Write the BITMAPFILEHEADER
		f.put('B').put('M');                           // bfType
		f << lwrite(headers_size + pixel_data_size, 4);  // bfSize
		f << lwrite(0, 2);  // bfReserved1
		f << lwrite(0, 2);  // bfReserved2
		f << lwrite(headers_size, 4);  // bfOffBits

		// Write the BITMAPINFOHEADER
		f << lwrite(40, 4);  // biSize
		f << lwrite(columns, 4);  // biWidth
		f << lwrite(rows, 4);  // biHeight
		f << lwrite(1, 2);  // biPlanes
		f << lwrite(24, 2);  // biBitCount
		f << lwrite(0, 4);  // biCompression=BI_RGB
		f << lwrite(pixel_data_size, 4);  // biSizeImage
		f << lwrite(0, 4);  // biXPelsPerMeter
		f << lwrite(0, 4);  // biYPelsPerMeter
		f << lwrite(0, 4);  // biClrUsed
		f << lwrite(0, 4);  // biClrImportant

		// Write the pixel data
		for (unsigned row = rows; row; row--)           // bottom-to-top
		{
			for (unsigned col = 0; col < columns; col++)  // left-to-right
			{
				unsigned char red, green, blue;
				//
				// This is how we convert an integer value to a color:
				// by mapping it evenly along the CIECAM02 hue color domain.
				//
				// http://en.wikipedia.org/wiki/Hue
				// http://en.wikipedia.org/wiki/hsl_and_hsv#conversion_from_hsv_to_rgb
				//
				// The following algorithm takes a few shortcuts since
				// both 'value' and 'saturation' are always 1.0.
				//
				double hue = (intarray[row - 1][col] - min_value) * granularity;
				int    H = //(int)(hue / 60) % 127;
					intarray[row - 1][col];
				double F = (hue / 60) - H;
				double Q = 1.0 - F;

#define c( x ) (255 * x)

				switch (type)
				{
				case TYPE_VOLCANIC:
					switch (H)
					{
					case 0:red = 255; green = blue = 0; break;
					case 1:red = green = 255; blue = 139;break;
					case 2:red = 252; green = 144; blue = 56;break;
					case 3:red = 255; green = 195, blue = 74;break;
					case 4:red = 147; green = 81; blue = 29;break;
					case 5:red = 71; green = 34; blue = 15;break;
					default:red = 46; green = 22; blue = 14;break;
					}
					break;
				case TYPE_DESERT_TATAOUINE:
					switch (H)
					{
					case 0:red = 255; green = blue = 0; break;
					case 1:red = 244; green = 195; blue = 136;break;
					case 2:red = 240; green = 168; blue = 109; break;
					case 3:red = 243; green = 160; blue = 106; break;
					default:red = 208; green = 101; blue = 59;
						break;
					}
					break;
				case TYPE_DESERT_GEO:
					switch (H)
					{
					case 0:red = 255; green = blue = 0; break;
					case 1:red = 246; green = 189; blue = 134; break;
					case 2:red = 239; green = 181; blue = 94; break;
					case 3:red = 251; green = 117; blue = 54; break;
					default:red = 47; green = 27; blue = 18; break;
						break;
					}
					break;
				case TYPE_DESERT_MARS:
					switch (H)
					{
					case 0:red = 255; green = blue = 0; break;
					case 1:red = 246; green = 110; blue = 2; break;
					case 2:red = 251; green = 119; blue = 18; break;
					case 3:red = 255; green = 81; blue = 30; break;
					case 4:red = 166; green = 49; blue = 14; break;
					default:
						red = 27; green = 3; blue = 1;
						break;
					}
					break;
				case TYPE_EARTHLIKE_FOREST:
					switch (H)
					{
					case 0:red = 255; green = blue = 0; break;
					case 1:red = 5; green = 21; blue = 99; break;
					case 2:red = 246; green = 243; blue = 166; break;
					case 3:red = 87; green = 132; blue = 99; break;
					case 4:red = 10; green = 87; blue = 33; break;
					default:
						red = 163; green = 137; blue = 62;
						break;
					}
					break;
				case TYPE_EARTHLIKE_TROPIC:
					switch (H)
					{
					case 0:red = 255; green = blue = 0; break;
					case 1:red = 71; green = 198; blue = 215; break;
					case 2:red = 128; green = 173; blue = 130; break;
					case 3:red = 63; green = 144; blue = 68; break;
					default:red = 36; green = 134; blue = 51; break;
						break;
					}
					break;
				case TYPE_EARTHLIKE_CYPRA:
					switch (H)
					{
					case 0:red = 255; green = blue = 0; break;
					case 1:red = 243; green = 186; blue = 79; break;
					case 2:red = 128; green = 173; blue = 130; break;
					case 3:red = 63; green = 144; blue = 68; break;
					default:red = 36; green = 134; blue = 51; break;
						break;
					}
					break;
				case TYPE_EARTHLIKE_MAGMA:
					switch (H)
					{
					case 0:red = 255; green = blue = 0; break;
					case 1:red = 255; green = 54; blue = 0; break;
					case 2:red = 128; green = 173; blue = 130; break;
					case 3:red = 63; green = 144; blue = 68; break;
					default:red = 36; green = 134; blue = 51; break;
						break;
					}
					break;
				case TYPE_ICE_ICE_BABY:
					switch (H)
					{
					case 0:red = 255; green = blue = 0; break;
					case 1:red = 0; green = blue = 255;break;
					case 2:red = 51; green = 255; blue = 255;break;
					case 3:red = 152; green = 255; blue = 255;break;
					case 4:red = blue = green = 224;break;
					case 5:red = blue = green = 240; break;
					default:
						red = blue = green = 255;
						break;
					}
					break;
				case TYPE_GAS_SATURN:
					switch (H)
					{
					case 0:red = 255; green = blue = 0; break;
					case 1:red = 223; green = 193; blue = 143; break;
					case 2:red = 177; green = 147; blue = 109; break;
					default:red = 53; green = 58; blue = 54; break;break;
					}
					break;
				case TYPE_GAS_NEPTUNE:
					switch (H)
					{
					case 0:red = 255; green = blue = 0; break;
					case 1:red = 73; green = 127; blue = 253; break;
					case 2:red = 57; green = 82; blue = 209; break;
					default:
						red = 45; green = 57; blue = 139;
						break;
					}
					break;
				case TYPE_GAS_PALESHELTER:
					switch (H)
					{
					case 0:red = 255; blue = green = 0; break;
					case 1:green = blue = red = 255; break;
					case 2:red = green = blue = 139; break;
					default:
						red = green = blue = 126;
						break;
					}

				
				default:
					red = blue = green = 255;
					break;
				}

				/*
				switch (H)
				{
				case 0:  red = c(1);  green = c(F);  blue = c(0);  break;
				case 1:  red = c(Q);  green = c(1);  blue = c(0);  break;
				case 2:  red = c(0);  green = c(1);  blue = c(F);  break;
				case 3:  red = c(0);  green = c(Q);  blue = c(1);  break;
				case 4:  red = c(F);  green = c(0);  blue = c(1);  break;
				default: red = c(1);  green = c(0);  blue = c(Q);
				}*/
#undef c
				//if (sqrt(pow(150 -(row - 1), 2) + pow(150 -col, 2)) <= (columns/2)){
					f.put(static_cast <char> (blue))
						.put(static_cast <char> (green))
						.put(static_cast <char> (red));
				//}
				//else{
					//f.put(static_cast <char> (0))
					//	.put(static_cast <char> (0))
					//	.put(static_cast <char> (255));
					
				//}
			}
			
			if (padding_size) f << lwrite(0, padding_size);
		}


		// All done!
		return f.good();
	}

	//--------------------------------------------------------------------------
	template <typename IntType>
	bool intarray2bmp(
		const std::string& filename,
		IntType*           intarray,
		unsigned           rows,
		unsigned           columns,
		IntType            min_value,
		IntType            max_value,
		IntType            type
		) {
		IntType** ia = new(std::nothrow) IntType*[rows];
		for (unsigned row = 0; row < rows; row++)
		{
			ia[row] = intarray + (row * columns);
		}
		bool result = intarray2bmp(
			filename, ia, rows, columns, min_value, max_value,type
			);
		delete[] ia;
		return result;
	}

} // namespace intarray2bmp
/*
#include<SDL.h>
bool generatePNG(const std::string &filepath){
	SDL_Surface *loaded = NULL, *optimised = NULL;
	loaded = IMG_Load(filepath.c_str());
	if (loaded != NULL){
		optimised = SDL_DisplayFormat
	}
}
*/

#endif
